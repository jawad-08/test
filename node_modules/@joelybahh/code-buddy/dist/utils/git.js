var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { simpleGit } from "simple-git";
import { determineCommitMessage } from "./openai.js";
const git = simpleGit();
var StagedFileType;
(function (StagedFileType) {
    StagedFileType["AllExceptDeleted"] = "allExceptDeleted";
    StagedFileType["Modified"] = "modified";
    StagedFileType["Deleted"] = "deleted";
    StagedFileType["All"] = "all";
})(StagedFileType || (StagedFileType = {}));
/**
 * Get staged files.
 * @param {string} scope - The scope to group files by.
 * @returns {Promise<string[]>} A promise that resolves to an array of staged files.
 */
export function getStagedFiles(type, scope) {
    return __awaiter(this, void 0, void 0, function* () {
        let status;
        try {
            status = yield git.status();
        }
        catch (error) {
            console.error("Error getting git status:", error);
            return [];
        }
        let files = status.files.map((file) => file.path);
        switch (type) {
            default:
            case StagedFileType.All:
                break;
            case StagedFileType.AllExceptDeleted:
                files = files.filter((file) => !status.deleted.includes(file));
                break;
            case StagedFileType.Modified:
                files = status.modified;
                break;
            case StagedFileType.Deleted:
                files = status.deleted;
                break;
        }
        return scope ? groupFilesByScope(files)[scope] || [] : files;
    });
}
/**
 * Get issue key from branch name.
 * @param {RegExp} regexp - The regular expression to match the issue key.
 * @returns {Promise<string | undefined>} A promise that resolves to the issue key or undefined.
 */
export function getIssueKeyFromBranchName(regexp = /[A-Za-z]+-\d+/) {
    return __awaiter(this, void 0, void 0, function* () {
        let branchName;
        try {
            branchName = (yield git.branchLocal()).current;
        }
        catch (error) {
            console.error("Error getting branch name:", error);
            return undefined;
        }
        const match = branchName.match(regexp);
        return match ? match[0] : undefined;
    });
}
/**
 * Get diff for specific files.
 * @param {string[]} files - The files to get the diff for.
 * @returns {Promise<string>} A promise that resolves to the diff for the specified files.
 */
export function getDiffForFiles(files) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return git.diff(["--cached", "--", ...files]);
        }
        catch (error) {
            console.error("Error getting diff for files:", error);
            return "";
        }
    });
}
/**
 * Commit changes.
 * @param {string} message - The commit message.
 * @returns {Promise<CommitResult | undefined>} A promise that resolves to the result of git.commit or undefined.
 */
export function commitChanges(message) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return git.commit(message);
        }
        catch (error) {
            console.error("Error committing changes:", error);
            return undefined;
        }
    });
}
import chalk from "chalk";
import { ScopeMode } from "../types/index.js";
import { loadConfig } from "../utils/openai.js";
/**
 * Group files by scope for a monorepo structure.
 * @param {string} file - The file to get the scope from.
 * @param {string[]} directories - An array of directories for the regex.
 * @returns {string | undefined} The scope of the file.
 */
function getScopeMonorepo(file, directories = ["apps", "packages", "functions"]) {
    const regexStr = directories.map((directory) => `(?:${directory}\/([^\/]+))`).join("|");
    const scopeMatch = file.match(new RegExp(`^${regexStr}`));
    if (scopeMatch) {
        // Matched groups start from index 1. As such, we need to return the first non-undefined group.
        for (let i = 1; i < scopeMatch.length; i++) {
            if (scopeMatch[i]) {
                return scopeMatch[i];
            }
        }
    }
}
/**
 * Group files by scope for a traditional structure.
 * @param {string} file - The file to get the scope from.
 * @param {string} srcDir - The name of the source directory.
 * @returns {string | undefined} The scope of the file.
 */
function getScopeTraditional(file, srcDir) {
    const pathParts = file.split("/");
    const srcIndex = pathParts.indexOf(srcDir);
    if (srcIndex !== -1 &&
        pathParts.length > srcIndex + 1 &&
        pathParts[srcIndex + 1] !== "index.ts") {
        return pathParts[srcIndex + 1]; // Returns the folder name right after `/src`
    }
    else {
        return ".";
    }
}
/**
 * Group files by scope.
 * @param {string[]} files - The files to group.
 * @returns {Promise<Record<string, string[]>>} An object mapping scopes to arrays of files.
 */
export function groupFilesByScope(files) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield loadConfig();
        const groups = {};
        for (const file of files) {
            let scope;
            switch (config.commit.scope.mode) {
                default:
                case ScopeMode.Traditional:
                    scope = getScopeTraditional(file, config.commit.scope.srcDir);
                    break;
                case ScopeMode.Monorepo:
                    scope = getScopeMonorepo(file);
                    break;
            }
            if (scope) {
                if (!groups[scope]) {
                    groups[scope] = [];
                }
                groups[scope].push(file);
            }
            else {
                if (!groups["."]) {
                    groups["."] = [];
                }
                groups["."].push(file);
            }
        }
        return groups;
    });
}
/**
 * Main function to handle commit.
 * @param {string} diff - The changes to commit.
 * @param {string} scope - The scope of changes.
 * @returns {Promise<void>} Nothing.
 */
export function commit(diff, scope, confirmCommit, args) {
    return __awaiter(this, void 0, void 0, function* () {
        let confirmed = false;
        let commitMessage = "";
        const { breaking, issue, message, type, reason } = args;
        while (!confirmed) {
            console.log(chalk.yellow("✨ Generating commit message..."));
            commitMessage = yield determineCommitMessage(diff, scope, type, reason);
            if (!commitMessage) {
                console.error("❌ Unable to generate commit message.");
                return;
            }
            const [message, accepted] = yield confirmCommit(commitMessage);
            if (accepted) {
                commitMessage = message;
                confirmed = true;
            }
        }
        try {
            yield commitChanges(commitMessage);
        }
        catch (error) {
            console.error("Error committing changes:", error);
        }
    });
}
/**
 * Main function to handle commit-all.
 * @param {string[]} diff - The changes to commit.
 * @param {string} scope - The scope of changes.
 * @returns {Promise<void>} Nothing.
 */
export function commitAll(confirmScope, confirmCommit, reduceDiff, args) {
    return __awaiter(this, void 0, void 0, function* () {
        const allExceptDeleted = yield getStagedFiles(StagedFileType.AllExceptDeleted);
        const deleted = yield getStagedFiles(StagedFileType.Deleted);
        // Store all files for grouping convinience
        const allFiles = [...allExceptDeleted, ...deleted];
        const groups = yield groupFilesByScope(allFiles);
        const { breaking, issue, message, scope: scopeOverride, type } = args;
        for (const scope in groups) {
            if (scopeOverride && scope !== scopeOverride)
                continue;
            const currentFiles = groups[scope];
            const filesToAdd = currentFiles.filter((file) => !deleted.includes(file));
            const filesToRemove = currentFiles.filter((file) => !allExceptDeleted.includes(file));
            const confirmedScope = scopeOverride ? true : yield confirmScope(scope);
            if (confirmedScope) {
                if (filesToAdd.length > 0)
                    yield git.add(currentFiles.filter((file) => !deleted.includes(file)));
                if (filesToRemove.length > 0)
                    yield git.rm(currentFiles.filter((file) => !allExceptDeleted.includes(file)));
                let diff = yield getDiffForFiles(filesToAdd);
                diff = yield reduceDiff(diff, groups[scope]);
                yield commit(diff, scope, confirmCommit, args);
            }
        }
    });
}
